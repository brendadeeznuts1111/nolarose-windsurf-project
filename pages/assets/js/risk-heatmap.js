var A={viridis:["#440154","#482777","#3f4a8a","#31678e","#26838f","#1f9d8a","#6cce5a","#b6de2b","#fee825"],plasma:["#0d0887","#6e00a8","#8c0aa5","#a8196d","#c12b42","#d5433d","#e66236","#f89441","#fce026"],inferno:["#000004","#1b0c41","#4a0c6b","#781c6d","#b5275f","#e45936","#f98e09","#f8c932","#fcffa4"],magma:["#000004","#180f3d","#440f76","#721f81","#9e2f7f","#cd4071","#f1605d","#fd9668","#fca50a","#f0f921"],blues:["#f7fbff","#deebf7","#c6dbef","#9ecae1","#6baed6","#4292c6","#2171b5","#08519c","#08306b"],reds:["#fff5f0","#fee0d2","#fcbba1","#fc9272","#fb6a4a","#ef3b2c","#cb181d","#a50f15","#67000d"]};class D{canvas;ctx;config;dataPoints=[];animationFrame=null;lastUpdateTime=0;constructor(q,B={}){let F=document.getElementById(q);if(!F)throw Error(`Canvas element with id '${q}' not found`);this.canvas=F,this.ctx=F.getContext("2d"),this.config={width:800,height:600,cellSize:20,colorScheme:"viridis",showGrid:!0,showLabels:!0,animationSpeed:1000,maxDataPoints:1000,...B},this.setupCanvas(),this.startAnimation()}setupCanvas(){this.canvas.width=this.config.width,this.canvas.height=this.config.height,this.ctx.imageSmoothingEnabled=!0;let q=window.devicePixelRatio||1,B=this.canvas.getBoundingClientRect();this.canvas.width=B.width*q,this.canvas.height=B.height*q,this.ctx.scale(q,q),this.canvas.style.width=B.width+"px",this.canvas.style.height=B.height+"px"}addDataPoint(q,B){let F={x:this.generateXCoordinate(q.merchantId),y:this.generateYCoordinate(q.timestamp),value:q.score,merchantId:q.merchantId,sessionId:q.sessionId,timestamp:q.timestamp,riskLevel:q.riskLevel,metadata:B};if(this.dataPoints.push(F),this.dataPoints.length>this.config.maxDataPoints)this.dataPoints.splice(0,this.dataPoints.length-this.config.maxDataPoints);console.log(`\uD83D\uDDFA️ Heatmap: Added point for ${q.merchantId} | Score: ${q.score.toFixed(3)} | Risk: ${q.riskLevel}`)}generateXCoordinate(q){let B=0;for(let F=0;F<q.length;F++)B=(B<<5)-B+q.charCodeAt(F),B=B&B;return Math.abs(B)%this.config.width}generateYCoordinate(q){let B=Date.now()-q,F=86400000,K=Math.min(B/86400000,1);return Math.floor(K*this.config.height)}getColorForValue(q){let B=A[this.config.colorScheme],F=Math.floor(q*(B.length-1));return B[Math.min(F,B.length-1)]}render2D(){if(this.ctx.clearRect(0,0,this.config.width,this.config.height),this.ctx.fillStyle="#1a1a1a",this.ctx.fillRect(0,0,this.config.width,this.config.height),this.config.showGrid)this.drawGrid();if(this.drawDataPoints(),this.config.showLabels)this.drawLabels();this.drawLegend()}drawGrid(){this.ctx.strokeStyle="rgba(255, 255, 255, 0.1)",this.ctx.lineWidth=1;for(let q=0;q<=this.config.width;q+=this.config.cellSize)this.ctx.beginPath(),this.ctx.moveTo(q,0),this.ctx.lineTo(q,this.config.height),this.ctx.stroke();for(let q=0;q<=this.config.height;q+=this.config.cellSize)this.ctx.beginPath(),this.ctx.moveTo(0,q),this.ctx.lineTo(this.config.width,q),this.ctx.stroke()}drawDataPoints(){let q=new Map;this.dataPoints.forEach((B)=>{let F=Math.floor(B.x/this.config.cellSize),K=Math.floor(B.y/this.config.cellSize),J=`${F},${K}`;if(!q.has(J))q.set(J,[]);q.get(J).push(B)}),q.forEach((B,F)=>{let[K,J]=F.split(",").map(Number),G=B.reduce(($,w)=>$+w.value,0)/B.length,Q=Math.max(...B.map(($)=>$.value)),N=K*this.config.cellSize,U=J*this.config.cellSize,Z=this.ctx.createRadialGradient(N+this.config.cellSize/2,U+this.config.cellSize/2,0,N+this.config.cellSize/2,U+this.config.cellSize/2,this.config.cellSize/2),W=this.getColorForValue(G);if(Z.addColorStop(0,W),Z.addColorStop(1,this.adjustColorOpacity(W,0.3)),this.ctx.fillStyle=Z,this.ctx.fillRect(N,U,this.config.cellSize,this.config.cellSize),Q>0.8)this.ctx.strokeStyle="rgba(255, 0, 0, 0.8)",this.ctx.lineWidth=2,this.ctx.strokeRect(N,U,this.config.cellSize,this.config.cellSize)})}drawLabels(){this.ctx.fillStyle="rgba(255, 255, 255, 0.8)",this.ctx.font="12px monospace",this.ctx.save(),this.ctx.translate(10,20),this.ctx.rotate(-Math.PI/2),this.ctx.fillText("Time (newer → older)",0,0),this.ctx.restore(),this.ctx.fillText("Merchant Distribution",this.config.width/2-50,this.config.height-10);let q=this.calculateStatistics();this.ctx.fillText(`Active: ${q.totalPoints} | Avg Risk: ${(q.avgRiskScore*100).toFixed(1)}%`,10,20)}drawLegend(){let q=this.config.width-150,B=20,F=120,K=200;this.ctx.fillStyle="rgba(0, 0, 0, 0.8)",this.ctx.fillRect(q,20,120,200),this.ctx.fillStyle="white",this.ctx.font="12px monospace",this.ctx.fillText("Risk Level",q+10,40);let J=this.ctx.createLinearGradient(q+10,50,q+10,150),G=A[this.config.colorScheme];G.forEach((U,Z)=>{J.addColorStop(Z/(G.length-1),U)}),this.ctx.fillStyle=J,this.ctx.fillRect(q+10,50,20,100),this.ctx.fillStyle="white",this.ctx.font="10px monospace",this.ctx.fillText("1.0",q+35,55),this.ctx.fillText("0.5",q+35,100),this.ctx.fillText("0.0",q+35,145);let Q=this.calculateStatistics(),N=170;this.ctx.fillText("Distribution:",q+10,N),Object.entries(Q.riskDistribution).forEach(([U,Z])=>{N+=15;let W=this.getRiskLevelColor(U);this.ctx.fillStyle=W,this.ctx.fillRect(q+10,N-10,10,10),this.ctx.fillStyle="white",this.ctx.fillText(`${U}: ${Z}`,q+25,N)})}generate3DData(){let q=[],B=[];this.dataPoints.forEach((G)=>{q.push({x:G.x,y:G.y,z:G.value*100,color:this.getColorForValue(G.value),size:Math.max(3,G.value*10),merchantId:G.merchantId,riskLevel:G.riskLevel})});let F=20;for(let G=0;G<this.config.width;G+=F)for(let Q=0;Q<this.config.height;Q+=F){let N=this.dataPoints.filter((U)=>Math.abs(U.x-G)<F&&Math.abs(U.y-Q)<F);if(N.length>0){let U=N.reduce((Z,W)=>Z+W.value,0)/N.length;B.push({x:G,y:Q,value:U,color:this.getColorForValue(U)})}}let K=this.calculateStatistics(),J=this.detectHotspots();return{points:q,grid:B,statistics:{...K,hotspots:J}}}calculateStatistics(){let q=this.dataPoints.length,B=q>0?this.dataPoints.reduce((J,G)=>J+G.value,0)/q:0,F=q>0?Math.max(...this.dataPoints.map((J)=>J.value)):0,K=this.dataPoints.reduce((J,G)=>{return J[G.riskLevel]=(J[G.riskLevel]||0)+1,J},{});return{totalPoints:q,avgRiskScore:B,maxRiskScore:F,riskDistribution:K}}detectHotspots(){let q=[],B=50,F=new Set;for(let K=0;K<this.dataPoints.length;K++){if(F.has(K))continue;let J=this.dataPoints[K];if(J.value<0.7)continue;let G=[J];F.add(K);for(let Q=K+1;Q<this.dataPoints.length;Q++){if(F.has(Q))continue;let N=this.dataPoints[Q];if(Math.sqrt((J.x-N.x)**2+(J.y-N.y)**2)<50&&N.value>0.7)G.push(N),F.add(Q)}if(G.length>2){let Q=G.reduce((W,$)=>W+$.x,0)/G.length,N=G.reduce((W,$)=>W+$.y,0)/G.length,U=G.reduce((W,$)=>W+$.value,0)/G.length,Z=Math.max(...G.map((W)=>Math.sqrt((W.x-Q)**2+(W.y-N)**2)));q.push({x:Q,y:N,intensity:U,radius:Z+20})}}return q}getRiskLevelColor(q){switch(q){case"critical":return"#ef4444";case"high":return"#f59e0b";case"medium":return"#eab308";case"low":return"#22c55e";default:return"#6b7280"}}adjustColorOpacity(q,B){let F=q.replace("#",""),K=parseInt(F.substr(0,2),16),J=parseInt(F.substr(2,2),16),G=parseInt(F.substr(4,2),16);return`rgba(${K}, ${J}, ${G}, ${B})`}startAnimation(){let q=(B)=>{if(B-this.lastUpdateTime>this.config.animationSpeed)this.render2D(),this.lastUpdateTime=B;this.animationFrame=requestAnimationFrame(q)};this.animationFrame=requestAnimationFrame(q)}stopAnimation(){if(this.animationFrame)cancelAnimationFrame(this.animationFrame),this.animationFrame=null}clearData(){this.dataPoints=[],this.render2D()}exportImage(){return this.canvas.toDataURL("image/png")}updateConfig(q){this.config={...this.config,...q},this.setupCanvas(),this.render2D()}getDataPoints(){return[...this.dataPoints]}filterByTimeRange(q,B){return this.dataPoints.filter((F)=>F.timestamp>=q&&F.timestamp<=B)}filterByRiskLevel(q){return this.dataPoints.filter((B)=>q.includes(B.riskLevel))}}function M(q,B){return new D(q,B)}function _(q){let F=q.generate3DData().statistics,K=`Risk heatmap analysis shows ${F.totalPoints} active data points with an average risk score of ${(F.avgRiskScore*100).toFixed(1)}%. Current risk distribution: ${Object.entries(F.riskDistribution).map(([G,Q])=>`${G} (${Q})`).join(", ")}.`,J=[];if(F.avgRiskScore>0.7)J.push("High overall risk levels detected - consider tightening thresholds");if(F.hotspots.length>0)J.push(`${F.hotspots.length} risk hotspots identified - investigate clustered fraud patterns`);if(F.riskDistribution.critical>F.totalPoints*0.1)J.push("Critical risk events above 10% - immediate security review recommended");return{summary:K,statistics:F,recommendations:J}}export{_ as generateHeatmapReport,M as createRiskHeatmap,D as RiskHeatmap};
